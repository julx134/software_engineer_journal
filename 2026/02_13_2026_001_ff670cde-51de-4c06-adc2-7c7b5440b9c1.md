- Initially designed the deserializer and mapper to instantiate an object for every `adv` field due to 'semantic' data format reasonings

- however, after confirming with my manager, we discussed constraints and the fact that we are going to be serving 400+ devices concurrently will not be a good design for the system because it will be 400+ object instances in memory per 1-2s.

- There was also an extra requirement in caching the device battery information (derived from the mqtt broker) into redis.

- However, the MQTT broker and listeners are already complicated via dynamic configuration and polymorphism + the fact that the SOSListener is also performing business-specific logic on top of mqtt message deserialization and filtering. The design was already too coupled (i.e. MQTT client management, message handling and deserialization, and sos business logic handling), that if we added a caching logic that we would have a coupled 'God' Listener.

- I suggested to leverage Spring Event capability since we were already using it in some parts of the code. We would decouple the mqtt logic (client management, subscription, and deserializing) with the business logic (i.e. caching + sos management). In that way, we have the mqtt service/infra which sole purpose is to do mqtt client management and message deserialization, and we could have the observer be correctly part of the business domain logic space.
