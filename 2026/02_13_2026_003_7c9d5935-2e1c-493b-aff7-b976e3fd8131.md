# Notes:

- With the licensing server validated and tested with the docker compose deployment on Ubuntu OS, I wanted to test it closer to the client environment which is where the application will be deployed.

- The client environment consists of a physical machine running VMWare ESXi hypervisor which manages multiple VMs. One of those VMs is allocated to us and specifically, it has to run Ubuntu Server OS because it needs to run headless.

- Since I did not access to a physical machine with VMWare ESXi installed, I still wanted to test one of the deployment abstractions which is the VM -> Docker Environemnt. From the testing so far, I was able to do HOST Ubuntu OS -> Docker Environemnt, and i wanted to bridge the gap such that even though I do not have access to the full client environment, we are already 2/3 of the way there.

- To stay as close with VMWare environment, I decided to download VMware Workstation because it was developed by the same company and it was free.

- The process was simple -- install and configure VMWorkstation to run a Ubuntu Server VM. Then, copy the already-built docker images from host unto the the VM. Start the containers.

- I ended up making it work, and suprisingly went well without a hitch. I was very concerned on the usb unplug/plug events because i did not know if my
  watchdog usb thread would detect the usb being unplugged and plugged back in. This is because there is a lot of abstraction from the HOST OS/Hypervisor -> VM -> Docker environment. However, all i needed to do was to manually connect the usb hardware (which was detected by VMWare Workstation) to the VM, and it worked as if it was running in Host. THe license server would automatically pick up the usb plug/unplug events, and reject license verification request from the backend and muxer containers accordingly. The whole architecture works which i am proud of

# Things I have learned:

- HOST OS is the OS that is running physically on the hardware
- GUEST OS is the OS that is running on the virtual machine
- Hypervisor is a software layer that sits between the virtual machine and the Host OS. From research, it seems there are 2 types of hypervisors: type 1 and type 2.
- Type 1 Hypervisors (like ESXi), also called bare metal hypervisors, is basically an O.S. in itself that sits on top of the hardware. It is designed to be lightweight and efficient with the core idea in mind (from my understanding) that the VMs will do the work (whatever the Guest OS is).
- Type 2 Hypervisors , also called Hosted, is what most people's first experience with VMs are (like me). It is the actual software the handles communications between the HOST OS and the VM OS. Examples of type 2 hypervisors are VMWare Workstation or VirtualBox. Because it has to sit in the middle between the HOST and the Guest OS, there is more latency with this type of hypervisors.
- Upon further research, it seems that modern OS's have blurred the lines between type 1 and 2 hypervisors in seeking more native and efficient virtualization. Many people consider them hybrid. For example with Linux OS, the OS launches KVM (Kernel-based Virtual Machine) module which allows the Guest OS to run instructions directly to the CPU and only needs to be stopped when accessing privilledged hardware like the storage.
- In other words for Linux OS, VMs are basically just like any other processes. It can run a certain instructions without requiring 'permission' from the HOST OS.
- I also learned about VMX (virtual machine extensions) modes. THere are two modes: 1. VMX Root Mode and 2. VMX non-root mode. From my understanding VMX root node is just privilleged access to the physical hardware, whereas VMX non-root mode will not have access to the physical hardware 'directly'.
- For type 1 hypervisors and KVM (to some extent), anytime the VM requires to to execute sinstructions, they are given VMX non-root mode access to the hardware. Whenever the instructions need to access certain privilledged hardware like the NIC or the storage, they would hand over control to the hypervisor (which is effectively running in VMX root mode), and perform the instructions/management of that instruction.
