# Journal Entry: February 13, 2026

**Project ID:** ff670cde-51de-4c06-adc2-7c7b5440b9c1 <br>
**Series:** 001 <br>
**TAGS:** #mqtt, #iot, #data_modeling, #memory_optimization, #architecture <br>

> **TLDR:** I initially designed our MQTT payload deserializer to strictly follow a "flat" semantic data model, instantiating a full wrapper object for every single `adv` entry. After initiation a discussion with my manager to validate the design, a quick reality check about our expected scale (**400+ concurrent devices**, **4000 msgs/s**) made me pivot immediately. We redesigned the payload to use lists, saving thousands of unnecessary object instantiations per second.

## Context

We have gateway devices that acts as a hub to aggregate information from the IOT devices within its range and publishes it to our mqtt server. This feature was to refactor the existing MQTT Service logic to accomodate for the new data format of the new IOT devices that will be replacing the old ones.

1. Gateway Data only

```json
{
  "tm": "2026-01-15T13:58:14.010Z",
  "gw": "ac233fc197a1",
  "seq": 517915,
  "adv": []
}
```

2. Gateway Data - payloadA data attached

```json
{
  "tm": "2026-01-15T13:58:11.010Z",
  "gw": "ac233fc197a1",
  "seq": 517912,
  "adv": [
    {
      "type": "ib",
      "uuid": "11111111111111111111111111111111",
      "major": 0,
      "minor": 0,
      "rssi_at_xm": -59,
      "rssi": -63,
      "tm": "2026-01-15T13:58:11.692Z",
      "mac": "c20303001699"
    }
  ]
}
```

3. Gateway Data - payloadB data attached

```json
{
  "tm": "2026-01-15T13:58:19.010Z",
  "gw": "ac233fc197a1",
  "seq": 517920,
  "adv": [
    {
      "type": "info",
      "battery": 50,
      "name": "B10",
      "rssi": -60,
      "tm": "2026-01-15T13:58:19.092Z",
      "mac": "c20303001699"
    }
  ]
}
```

## The Assumption: "Flatten Everything"

When refactoring the new MQTT data format, my initial thought process was heavily biased toward domain clarity and semantic purity. I created a polymorphic base class where the parent abstract class held common header fields (like `gw`, `seq`, and `tm`).

Based on a sample payload I was looking at, I assumed the cleanest approach was to spawn a new concrete object for _each_ entry within the raw `adv` JSON array. In my head, I pictured flattening the array: instead of a single wrapper containing a list of `adv` payloads, I would instantiate a full wrapper object for every individual payload. The `adv` field in my Java class was a singular `T adv`, not a list.

This felt like "clean code." The resulting objects would be incredibly straightforward to process, get, and set fields on downstream because each object represented exactly one discrete information from an IOT device.

## The Reality Check: 400 Gateway, 800 Devices, and 4000 msgs/s

Once I had a working prototype of this deserializer, I took the initiative to sit down with my manager and walk through the trade-offs of the design. It's always easier to discuss architecture when you have a tangible implementation rather than just theory.

That conversation had changed my perspective..

He clarified a massive requirement: the `adv` field would actually contain _multiple_ entries of the same type in production. My initial design worked flawlessly if we were processing maybe 20 messages at a time. However, our actual production load is going to be serving **800+ devices** concurrently, which roughly equates to **4000 msgs/s**.

If we kept my original design, the system would be taking a raw payload containing 10 `adv` entries and instantiating 10 massive wrapper objects. At scale, we would be instantiating thousands of wrapper objects in memory every single second. In a high-throughput Java environment, that is a recipe for CPU exhaustion (via object instantiation overhead) and crippling Garbage Collection (GC) pauses.

## The Refactor: Aggregated Lists

The pivot was obvious: I needed to redesign the classes to only instantiate the heavy wrapper objects _on demand_.

Instead of `T adv`, the base class needed to use `List<T> adv`. We would instantiate the parent wrapper message exactly _once_ per incoming raw payload. Then, we would simply iterate through the `adv` array, deserialize the lightweight payload objects (like `PayloadMessageA`), and append them to the wrapper's list.

### Code Comparison: Old vs. New

Here is exactly how the shift from "flattened objects" to "aggregated lists" changed the deserialization logic.

**The Old Way (Memory Hog):**

```java
@Data
public abstract class BaseMqttMessage<T> {
    private String tm;
    private String gw;
    private Long seq;
    private T adv; // EXPENSIVE: Singular generic type forces a 1:1 wrapper-to-payload ratio
}

private List<BaseMqttMessage<?>> deserializeMessage(MqttMessage msg) {
    List<BaseMqttMessage<?>> parsedMessages = new ArrayList<>();
    try {
        JsonNode rootNode = objectMapper.readTree(new String(msg.getPayload()));
        if (!rootNode.has("adv")) return parsedMessages;

        JsonNode advNode = rootNode.get("adv");
        // ... (empty check omitted)
        else {
            for (JsonNode node : advNode) {
                String type = node.path("type").asText();
                ObjectNode objectNode = (ObjectNode) rootNode;

                // EXPENSIVE: We mutate the root node to hold a single 'adv' item
                objectNode.set("adv", node);

                if (MQTTConstant.TYPE_A_IDENTIFIER.equals(type)) {
                    // EXPENSIVE: Instantiating a FULL wrapper message for every single item in the array
                    ConcreteMessageA wrapper = objectMapper.convertValue(objectNode, ConcreteMessageA.class);
                    parsedMessages.add(wrapper);
                }
                // ... other types omitted
            }
        }
    } catch (Exception e) {
        log.error("Error deserializing message: {}", e.getMessage(), e);
    }
    return parsedMessages;
}
}
```

**The New Way (Efficient Aggregation):**

```java
@Data
public abstract class BaseMqttMessage<T> {
    private String tm;
    private String gw;
    private Long seq;
    private List<T> adv; // EFFICIENT: List allows one wrapper to hold multiple payloads
}

private List<BaseMqttMessage<?>> deserializeMessage(MqttMessage msg) {
    List<BaseMqttMessage<?>> parsedMessages = new ArrayList<>();
    try {
        JsonNode rootNode = objectMapper.readTree(new String(msg.getPayload()));
        if (!rootNode.has("adv")) return parsedMessages;

        JsonNode advNode = rootNode.get("adv");
        // ... (empty check omitted)
        else {
            ObjectNode parentObject = (ObjectNode) rootNode;
            parentObject.set("adv", objectMapper.createArrayNode());

            // EFFICIENT: Instantiate the heavy wrapper messages exactly ONCE
            ConcreteMessageA msgA = objectMapper.convertValue(parentObject, ConcreteMessageA.class);
            ConcreteMessageB msgB = objectMapper.convertValue(parentObject, ConcreteMessageB.class);

            for (JsonNode node : advNode) {
                String type = node.path("type").asText();
                ObjectNode advObject = (ObjectNode) node;

                if (MQTTConstant.TYPE_A_IDENTIFIER.equals(type)) {
                    // EFFICIENT: Only instantiate the lightweight inner payload
                    DataPayloadA payloadA = objectMapper.convertValue(advObject, DataPayloadA.class);
                    msgA.getAdv().add(payloadA); // Add to the single wrapper's list
                }
                else if (MQTTConstant.TYPE_B_IDENTIFIER.equals(type)) {
                    DataPayloadB payloadB = objectMapper.convertValue(advObject, DataPayloadB.class);
                    msgB.getAdv().add(payloadB);
                }
            }
            parsedMessages.add(msgA);
            parsedMessages.add(msgB);
        }
    } catch (Exception e) {
        log.error("Error deserializing message: {}", e.getMessage(), e);
    }
    return parsedMessages;
}
```

## Summary / Key Takeaway

By shifting the `adv` property from a single object to a list, we dramatically reduced the object instantiation overhead. This prevents the JVM from spinning up thousands of heavy wrapper objects per second under load. It was a great reminder that what seems like "clean, readable design" in isolation can become a massive performance bottleneck at scale. This was a good reminder to me that unclear assumptions, if unchecked, can lead to innocent mistakes.
