# 001

- As part of our weekly meeting, we usually update our manager on what we've accomplished and discuss any remaining tasks. For this particular meeting, my updates were approved, and I was assigned two features to complete before our big deployment in late Spring 2026. The first feature is to auto-assign IoT buttons to each room, and the second is to implement a Redis cache that populates when the server starts. Usually, these meetings take about 30 minutes and are straightforward, but this conversation ended up running much longer. The requirements were a bit unclear, which reminds me of why it's so important to clarify requirements before jumping into a solution. I initially had zero context, and my manager gave me only a sentence or two for each feature. Before leaving the meeting, I took the initiative to clarify the specifics.

  The first task was auto-assigning buttons to each room. This was vague because he simply said that once the CRUD features for the IoT button entities were finished, I should take over and auto-assign them. Specifically, each room requires three buttons: two buttons of type C-10 or B-10, and one "pull" button. I needed to understand exactly what "auto-assignment" entailed. My first thought was to clarify the exact button composition per room. I asked whether each room needed two of each (B-10 and C-10) or two total from that set. I also questioned if we would ever use only one specific type. My manager pulled up a diagram showing that each room requires a total of three buttons: one pull button and two of a single type (either B-10 or C-10). The reason it could be either type was simply that he hadn't confirmed which one we had in stock.

  Beyond the composition, I had to clarify the logic for the assignment process itself. I asked if we should roll back the entire process if we didn't have enough buttons to fulfill all rooms. For instance, if we had 20 rooms but only 10 buttons. He clarified that we wouldn't roll back; we would keep whatever assignments were successfully made. My next question was about partial fulfillment: if a room requires three buttons but we only have one or two available, do we still assign them or skip that room? He confirmed that we do not allow partial fulfillment; we only perform full fulfillments per room. With those details settled, the algorithm itself is simple: I just need to identify rooms without assigned buttons and allocate them accordingly.

  The second feature was more difficult to scope because it was tightly coupled with business logic. He originally stated that on server startup, the Redis cache should look for a list of events, and if five or more of a particular type exist, we should send a WebSocket event to the frontend client. I had to clarify if we even had a service to read from Redis during application startup. My manager noted we didn't, but suggested I could implement it if time allowed. I was still confused and tried to summarize his requirement, but my interpretation was incorrect. He then shared his screen to show me the actual requirement: on application startup, a function or script should read from the database to check for unacknowledged events. Any unacknowledged events should be cached into the Redis database. If Redis then contains enough events of a particular type, we trigger the WebSocket event to the frontend.

  For clarifications like these, I’ve learned to always write a sentence or two that explains the entire task in my own words and repeat it back to my manager. If my interpretation is correct, he approves it; if not, we refine it until the ambiguities are gone. This is a process I've developed through experience. One thing I love about software engineering and something I’ve learned about my own workflow is that you should never start implementing big system designs or features without clearing up these ambiguities. In the past, I’ve jumped into tasks only to hit a wall midway through because of an unaddressed detail. Having to reach out to a busy manager at that point breaks the implementation flow and is generally inefficient. For this meeting and these features, that proactive clarification was the key lesson.

# 002
